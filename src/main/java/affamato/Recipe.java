//@Author Alex Issa
package affamato;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Random;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import com.googlecode.objectify.ObjectifyService;
import com.googlecode.objectify.annotation.Entity;
import com.googlecode.objectify.annotation.Id;
import com.googlecode.objectify.annotation.Index;

@Entity
public class Recipe implements Comparable<Recipe> 
{
    @Id Long id; //The @Id field 	can be of type Long, long, or String. 
    //If you use Long and save an entity with a null id, a numeric value will be 
    //generated for you using the standard GAE allocator for this kind. If you use 
    //String or the primitive long type, values will never be autogenerated.
    @Index String jsonString;
    @Index String title;
    @Index Boolean vegetarian;
    @Index Boolean glutenFree;
    @Index Boolean dairyFree;
    @Index Boolean ketogenic;
    @Index Boolean vegan;
    @Index Integer cookMinutes;
    @Index Integer prepMinutes;
    @Index String instructions;
    
    private Recipe() {}
    public Recipe(String json) 
    {
    	jsonString = json;
    	JSONObject jo = null;
    	try 
    	{
			jo = new JSONObject(json);
			
			Object titleJSON = jo.get("title");
			title = titleJSON.toString();
			this.vegetarian = jo.getBoolean("vegetarian");
			this.glutenFree = jo.getBoolean("glutenFree");
			this.dairyFree = jo.getBoolean("dairyFree");
			this.ketogenic = jo.getBoolean("ketogenic");
			this.vegan = jo.getBoolean("vegan");
    		if(jo.has("cookingMinutes")) this.cookMinutes = jo.getInt("cookingMinutes");
    		else this.cookMinutes = 0;
			if(jo.has("preparationMinutes")) this.prepMinutes = jo.getInt("preparationMinutes");
			else this.prepMinutes = 0;
			if(jo.has("instructions")) this.instructions = jo.getString("instructions");
			else this.instructions = "";
			
			JSONArray extIngredients = jo.getJSONArray("extendedIngredients");
			
		} 
    	catch (JSONException e) 
    	{
			e.printStackTrace();
		}
    }

    //Unimplemented
    @Override
    public int compareTo(Recipe other) {
    	return 0;
    }
     
    //UNTESTED METHOD
    @Override 
    public boolean equals(Object o) 
    {
    	if(o instanceof Recipe) 
    	{
    		Recipe r = (Recipe) o;
    		if(r.title.equals(this.title)) 
    		{
    			return true;
    		}
    		else 
    		{
    			return false;
    		}
    	} 
    	else if(o instanceof String) 
    	{
    		String r = (String) o;
    		if(r.equals(this.title)) 
    		{
    			return true;
    		}
    		else 
    		{
    			return false;
    		}
    	}
    	else 
    	{
    		return false;
    	}
    }
    
    @Override
    public int hashCode()
    {
    	return jsonString.hashCode();
    }
    
    public static JSONObject randomRecipe() {
    	List<Recipe> recipes = ObjectifyService.ofy().load().type(Recipe.class).list();
    	int size = recipes.size();
    	Recipe r = recipes.get(new Random().nextInt(size));
    	JSONObject json = new JSONObject(r.jsonString);
		JSONArray extIngredients = json.getJSONArray("extendedIngredients");
		String url = json.getString("sourceUrl");
    	
    	return new JSONObject().put("title", r.title).put("vegetarian", r.vegetarian).put("glutenFree", r.glutenFree)
							.put("dairyFree", r.dairyFree).put("ketogenic", r.ketogenic)
							.put("vegan", r.vegan).put("cookMinutes", r.cookMinutes)
							.put("prepMinutes", r.prepMinutes).put("id", r.id).put("instructions", r.instructions).put("ingredients",extIngredients).put("url", url);
    }
    
    public static JSONArray searchRecipe(String search, FilterParameters param, Cook c) {
    	JSONArray returner = new JSONArray();
    	List<Recipe> recipes = ObjectifyService.ofy().load().type(Recipe.class).list();
    	for (int i = 0; i < recipes.size(); i++) 
		{
			
			Recipe r = recipes.get(i);
			
			
			if (r.title.toLowerCase().contains(search.toLowerCase()) && param.valid(r)) {
			
				if(param.isUsingStuff()) {
					if(param.useExpiring) {
						param.calculateExpiring(r, c);
					}
					if(param.useInventory) {
						param.calculateInventories(r, c);
					}
				}
				else {
	    			JSONObject json = new JSONObject(r.jsonString);
	    			JSONArray extIngredients = json.getJSONArray("extendedIngredients");
	    			String url = json.getString("sourceUrl");
					returner.put(new JSONObject().put("title", r.title)
							.put("vegetarian", r.vegetarian).put("glutenFree", r.glutenFree)
							.put("dairyFree", r.dairyFree).put("ketogenic", r.ketogenic)
							.put("vegan", r.vegan).put("cookMinutes", r.cookMinutes)
							.put("prepMinutes", r.prepMinutes).put("id", r.id).put("instructions", r.instructions).put("ingredients",extIngredients).put("url", url));
				}
				
			}
		}
    	if(param.isUsingStuff()) {
    		Map<Recipe, Float> recipeValue = param.sortAndReturn();
    		for(Recipe r : recipeValue.keySet()) {
    			JSONObject json = new JSONObject(r.jsonString);
    			JSONArray extIngredients = json.getJSONArray("extendedIngredients");
    			String url = json.getString("sourceUrl");
    			returner.put(new JSONObject().put("title", r.title)
						.put("vegetarian", r.vegetarian).put("glutenFree", r.glutenFree)
						.put("dairyFree", r.dairyFree).put("ketogenic", r.ketogenic)
						.put("vegan", r.vegan).put("cookMinutes", r.cookMinutes)
						.put("prepMinutes", r.prepMinutes).put("id", r.id).put("instructions", r.instructions).put("ingredientArray", extIngredients).put("url", url));
    		}
    	}
    	return returner;
    }
    
} 
